\documentclass[a4paper,12pt]{article}
\usepackage[utf8]{inputenc}
\usepackage{amsfonts}
\usepackage{enumerate}
\usepackage{amsmath}
\usepackage{array}
\usepackage{xcolor}
\usepackage{graphicx}
\usepackage{listings}
\graphicspath{ {images/} }

\usepackage[top=1in,bottom=1in,left=0.5in,right=0.5in]{geometry}

\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{codered}{rgb}{0.6,0,0}
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}

\lstset{
    escapeinside={(*}{*)},
}

\lstdefinestyle{myeiffel}{
    backgroundcolor=\color{backcolour},
    commentstyle=\color{codegreen},
    keywordstyle=\color{magenta},
    numberstyle=\tiny\color{codegray},
    stringstyle=\color{codepurple},
    basicstyle=\ttfamily\footnotesize,
    breakatwhitespace=false,
    breaklines=true,
    captionpos=b,
    keepspaces=true,
    % numbers=left,
    numbersep=5pt,
    showspaces=false,
    showstringspaces=false,
    showtabs=false,
    tabsize=2,
    emph={IDENTIFIER, RESERVED_TYPE, STRING, COMMENT, NUMBER},
    emphstyle=\color{magenta},
}

\lstdefinestyle{DOS}{
    backgroundcolor=\color{black},
    basicstyle=\color{white}\ttfamily,
    morekeywords={,tabular,toprule,midrule,bottomrule},
    otherkeywords={:, \$},
    keywordstyle=\color{green},
    emph={username, path},
    emphstyle=\color{green},
}

\title{
    \includegraphics[scale=1.3]{logo-UNQ}\\
    \vspace{4mm}
    \huge{Parseo y generación de código  \\
        \vspace{4mm}
        Trabajo Práctico - Analizador Léxico de Eiffel} }
\author{Gastón Veliez - B. Emmanuel Pericon}
\date{Septiembre 26, 2025}

\renewcommand{\contentsname}{Indice}

\begin{document}

\maketitle

\tableofcontents

\newpage

\section{Introducción}

\vspace{4mm}
Implementar un analizador léxico para el lenguaje Eiffel, que permita reconocer
correctamente los tokens básicos de un programa escrito en dicho lenguaje.
El analizador se debe construir utilizando las herramientas Flex (generador de
analizadores
léxicos) y Bison (generador de analizadores sintácticos), aunque en esta etapa
del trabajo
sólo se requerirá implementar la parte léxica.

\vspace{6mm}
\section{Diseño del analizador}
\vspace{4mm}

En este analizador tenemos dos archivos importantes, que son:

\begin{itemize}
    \item Por un lado el \textbf{eiffel.l}, que contiene la definición de
          las
          expresiones regulares de los tokens, directamente relacionado con
          \textbf{Flex}.
    \item Y por otro, el archivo \textbf{syntacticAnalyzer.y}, utilizado
          por
          \textbf{Bison} para coordinar la lectura de tokens y dar una
          salida entendible.
\end{itemize}

\noindent
En esta entrega vamos a centrarnos en el analizador léxico generado por Flex. \\

\noindent
Para abordar el problema se modela un subconjunto del lenguaje Eiffel como una
Gramática Libre de Contexto. Se define como:
\[
    G = (V, \Sigma, P, S)
\]
donde $V$ es el conjunto de no-terminales, $\Sigma$ el conjunto de terminales
(tokens), $P$ el conjunto de producciones y $S$ el símbolo inicial.

\subsection{Terminales}
Los terminales corresponden a los tokens que el analizador léxico debe
reconocer:
\begin{itemize}
    \item Palabras reservadas: \texttt{class}, \texttt{inherit},
          \texttt{create},
          \texttt{feature}, \texttt{main}, \texttt{do},
          \texttt{from}, \texttt{until},
          \texttt{loop},
          \texttt{end}, \texttt{if},
          \texttt{then}, \texttt{else}, \texttt{make}, \texttt{print},
          \texttt{require}, \texttt{ensure}, \texttt{invariant},
          \texttt{true}, \texttt{false},
          \texttt{INTEGER}, \texttt{BOOLEAN}, \texttt{STRING}.
    \item Identificadores: \texttt{IDENTIFIER}.
    \item Constantes: \texttt{NUMBER}, \texttt{REAL}, \texttt{STRING}.
    \item Operadores y símbolos:  \texttt{+}, \texttt{-},
          \texttt{*}, \texttt{/},
          \texttt{=}, \texttt{!=},
          \texttt{<=}, \texttt{<},
          \texttt{>}, \texttt{>=},
          \texttt{not}, \texttt{and},\texttt{or},
          \texttt{:=}, \texttt{(}, \texttt{)}, 
          \texttt{:}, \texttt{,}.
\end{itemize}

\subsection{Reglas de producción}
Las producciones no fueron realizadas por el alcance de la entrega.


\section{Diseño del analizador léxico}
\vspace{4mm}
El analizador con Flex se describe mediante expresiones regulares, que Flex
traduce internamente en autómatas finitos determinísticos.
Se trato de obtener la mayor cantidad de tokens posibles (extendiendo la
implementación con otras carácteristicas de el lenguaje no presentes en el
ejemplo) con las expresiones a
continuación:

\begin{lstlisting}[language=Eiffel, style=myeiffel]
"class"           { return CLASS; }
"inherit"         { return INHERIT; }
"create"          { return CREATE; }
"feature"         { return FEATURE; }
"main"            { return MAIN; }
"do"              { return DO; }
"from"            { return FROM; }
"until"           { return UNTIL; }
"loop"            { return LOOP; }
"end"             { return END; }
"if"              { return IF; }
"then"            { return THEN; }
"else"            { return ELSE; }
"make"            { return MAKE; }
"print"           { return PRINT; }
"invariant"       { return INVARIANT; }
"ensure"          { return ENSURE; }
"require"         { return REQUIRE; }
{RESERVED_TYPE}   { return RESERVED_TYPE; }
"+"               { return PLUS; }
"-"               { return MINUS; }
"*"               { return TIMES; }
"/"               { return DIVIDE; }
">"               { return GREATER; }
"<"               { return LESS; }
"="               { return EQUAL; }
"!="              { return NOT_EQUAL; }
">="              { return GREATER_EQUAL; }
"<="              { return LESS_EQUAL; }
"not"             { return NOT; }
"and"             { return AND; }
"or"              { return OR; }
"true"            { return TRUE; }
"false"           { return FALSE; }
":="              { return ASSIGN; }
":"               { return COLON; }
","               { return COMMA; }
"("               { return PARENTHESIS_OPEN; }
{STR}             { return STRING; }
")"               { return PARENTHESIS_CLOSE; }
{COMMENT}         { return COMMENT; }
{IDENTIFIER}      { return IDENTIFIER; }
{NUMBER}          { return NUMBER; }
{REAL}            { return REAL; }

[ \t\n\r]+        ;
.                 { return UNKNOWN; }
\end{lstlisting}

\newpage

\noindent
Algunos expresiones particulares fueron:

\begin{lstlisting}[style=myeiffel]
\\ Toda palabra con letras minusculas/mayusculas y/o guion bajo
IDENTIFIER [a-zA-Z][0-9_a-zA-Z]*  

\\ Un numero
DIGIT [0-9]

\\ Uno o mas numeros enteros
NUMBER [0-9]+

\\Uno o mas numeros reales
REAL ({DIGIT}+\.[0-9]*([eE][+-]?{DIGIT}+)?|{DIGIT}+[eE][+-]?{DIGIT}+)

\\ Todo string, cualquier caracter que se encuentre entre comillas
STR \"[^\"]*\"

\\ Algunas palabras reservadas para tipos
RESERVED_TYPE (INTEGER|BOOLEAN|STRING)

\\ Los comentarios, estos comienzan con doble guion medio
COMMENT \-{2}.*

\\ Ignorar espacios y saltos de linea
[ \t\n\r]+ 

\\ El punto es para lo no reconocido por el resto de expresiones
.
\end{lstlisting}

\newpage
\section{Diseño del analizador sintáctico}
\vspace{4mm}
% El parser se implementa en Bison como un \emph{analizador sintáctico} de tipo
% \emph{bottom-up}, siguiendo las producciones de la Gramática. Bison genera
% automáticamente las tablas de análisis a partir de las reglas mostrando el tipo
% de token con su lexema asociado.

% \subsection{Reglas}
Para este trabajo práctico Bison solo se encargará de la lectura de los tokens
producido por Flex y lo traducirá a una salida fácil de entender para el
usuario, mediante las siguientes reglas (se simplifica para mayor
entendimiento):

\begin{lstlisting}[language=Eiffel, style=myeiffel]
    CLASS                 print de TOKEN_CLASS               -> +Lexema asociado
    | CREATE              print de TOKEN_CREATE              -> +Lexema asociado
    | FEATURE             print de TOKEN_FEATURE             -> +Lexema asociado
    | DO                  print de TOKEN_DO                  -> +Lexema asociado
    | END                 print de TOKEN_END                 -> +Lexema asociado
    | IF                  print de TOKEN_IF                  -> +Lexema asociado
    | THEN                print de TOKEN_THEN                -> +Lexema asociado
    | ELSE                print de TOKEN_ELSE                -> +Lexema asociado
    | FROM                print de TOKEN_FROM                -> +Lexema asociado
    | UNTIL               print de TOKEN_UNTIL               -> +Lexema asociado
    | LOOP                print de TOKEN_LOOP                -> +Lexema asociado
    | INHERIT             print de TOKEN_INHERIT             -> +Lexema asociado
    | MAKE                print de TOKEN_MAKE                -> +Lexema asociado
    | MAIN                print de TOKEN_MAIN                -> +Lexema asociado
    | PRINT               print de TOKEN_PRINT               -> +Lexema asociado
    | REQUIRE             print de TOKEN_PRINT               -> +Lexema asociado
    | ENSURE              print de TOKEN_PRINT               -> +Lexema asociado
    | INVARIANT           print de TOKEN_PRINT               -> +Lexema asociado
    | IDENTIFIER          print de TOKEN_IDENTIFIER          -> +Lexema asociado
    | NUMBER              print de TOKEN_NUMBER              -> +Lexema asociado
    | REAL                print de TOKEN_REAL                -> +Lexema asociado
    | STRING              print de TOKEN_STRING              -> +Lexema asociado
    | TRUE                print de TOKEN_TRUE                -> +Lexema asociado
    | FALSE               print de TOKEN_FALSE               -> +Lexema asociado
    | PLUS                print de TOKEN_PLUS                -> +Lexema asociado
    | MINUS               print de TOKEN_MINUS               -> +Lexema asociado
    | TIMES               print de TOKEN_TIMES               -> +Lexema asociado
    | DIVIDE              print de TOKEN_DIVIDE              -> +Lexema asociado
    | ASSIGN              print de TOKEN_ASSIGN              -> +Lexema asociado
    | EQUAL               print de TOKEN_EQUAL               -> +Lexema asociado
    | LESS                print de TOKEN_LESS                -> +Lexema asociado
    | GREATER             print de TOKEN_GREATER             -> +Lexema asociado
    | LESS_EQUAL          print de TOKEN_LESS_EQUAL          -> +Lexema asociado
    | GREATER_EQUAL       print de TOKEN_GREATER_EQUAL       -> +Lexema asociado
    | PARENTHESIS_OPEN    print de TOKEN_PARENTHESIS_OPEN    -> +Lexema asociado
    | PARENTHESIS_CLOSE   print de TOKEN_PARENTHESIS_CLOSE   -> +Lexema asociado
    | COLON               print de TOKEN_SEMI                -> +Lexema asociado
    | COMMA               print de TOKEN_COMMA               -> +Lexema asociado
    | RESERVED_TYPE       print de TOKEN_RESERVED_TYPE       -> +Lexema asociado
    | NOT                 print de TOKEN_NOT                 -> +Lexema asociado
    | NOT_EQUAL           print de TOKEN_NOT_EQUAL           -> +Lexema asociado
    | OR                  print de TOKEN_OR                  -> +Lexema asociado
    | AND                 print de TOKEN_AND                 -> +Lexema asociado
    | COMMENT             print de TOKEN_COMMENT             -> +Lexema asociado
    | UNKNOWN             print de TOKEN_UNKNOWN             -> +Lexema asociado

\end{lstlisting}
\vspace{6mm}
\section{Compilación y ejecución}
\vspace{4mm}

\noindent
Necesitamos realizar una compilación de los archivos de la siguiente manera:

\begin{lstlisting}[style=DOS]
username:path$  flex eiffel.l
username:path$  bison -d syntacticAnalyzer.y
username:path$  gcc -o executable lex.yy.c syntacticAnalyzer.tab.c
\end{lstlisting}

\vspace{4mm}
\noindent
Por ejemplo, para el siguiente codigo en el archivo \textbf{tests/test.e}:

\begin{lstlisting}[language=Eiffel, style=myeiffel]
class HELLO_WORLD
create
    make
feature
    make
        do
            print ("Hola,utilizo Eiffel!%N")
        end
end
\end{lstlisting}

\vspace{4mm}
\noindent
A la hora de ejecutarse se realiza y ve de esta manera:

\begin{lstlisting}[style=DOS]
username:path$  ./executable  < tests/test.e 
TOKEN_CLASS                   -> class
TOKEN_IDENTIFIER              -> HELLO_WORLD
TOKEN_CREATE                  -> create
TOKEN_MAKE                    -> make
TOKEN_FEATURE                 -> feature
TOKEN_MAKE                    -> make
TOKEN_DO                      -> do
TOKEN_PRINT                   -> print
TOKEN_PARENTHESIS_OPEN        -> (
TOKEN_STRING                  -> "Hola,utilizo Eiffel!%N"
TOKEN_PARENTHESIS_CLOSE       -> )
TOKEN_END                     -> end
TOKEN_END                     -> end
\end{lstlisting}

\newpage
\section{Reseña del lenguaje Eiffel y su origen}
\vspace{4mm}

\subsection{Lenguaje Eiffel}

Eiffel es un lenguaje de programación orientado a objetos, creado a mediados de
los años 80 por \textbf{Bertrand Meyer}, un informático francés, mientras
trabajaba en la empresa \textit{Interactive Software Engineering} (ISE).

\noindent
Su diseño está fuertemente ligado al ámbito académico, ya que Meyer era
profesor e
investigador y buscaba un lenguaje que sirviera como vehículo académico para
difundir y aplicar los principios de \textit{programación por contrato}
(\textit{Design by Contract}), una metodología introducida por Meyer que
establece que cada componente de software debe definirse con
\textbf{precondiciones, postcondiciones e invariantes}. Esto promueve la
confiabilidad, reutilización y mantenibilidad del código.

\noindent
El nombre Eiffel hace referencia a la \textit{torre Eiffel} en París, símbolo
de ingeniería sólida y elegante, lo cual refleja el espíritu con el que fue
concebido: construir sistemas de software tan robustos y bien diseñados como
una obra de ingeniería.

\subsection{Principios fundamentales}

\begin{itemize}
    \item \textbf{Orientación a objetos pura}: todo en Eiffel es objeto,
          incluso los tipos básicos.
    \item \textbf{Diseño por contrato (Design by Contract, DbC)}:
          \begin{itemize}
              \item Una de sus mayores innovaciones.
              \item Cada clase, método o módulo se especifica con
                    precondiciones,
                    postcondiciones e invariantes, como un contrato formal
                    entre el código y sus
                    usuarios.
              \item Esto fomenta la confiabilidad y la verificación del
                    software.
          \end{itemize}
    \item \textbf{Simplicidad y legibilidad}: la sintaxis busca ser clara y
          cercana al lenguaje natural.
    \item \textbf{Soporte de herencia múltiple y polimorfismo}.
\end{itemize}

\subsection{Origen universitario}

Bertrand Meyer desarrolló Eiffel inicialmente en el IT Department de
\textit{Interactive Software Engineering} (hoy Eiffel Software), pero el
lenguaje alcanzó su madurez y estandarización en el ámbito universitario, sobre
todo en el \textbf{ETH Zürich} (Escuela Politécnica Federal de Zúrich, Suiza),
donde Meyer ejerció como profesor de informática desde los años 90.

\noindent
Desde entonces, Eiffel ha sido un lenguaje estrechamente ligado a la academia,
aunque también tuvo aplicaciones en la industria en sectores donde la
confiabilidad del software es crítica (banca, aeroespacial, defensa).

\subsection{Legado}

Aunque no alcanzó la popularidad masiva de Java o C++, Eiffel influyó
enormemente en la evolución del software: el concepto de \textit{Design by
    Contract} fue adoptado por otros lenguajes (Ada 2012, C\#, Java mediante
librerías, Python mediante decoradores, etc.).

\noindent
Sigue siendo un referente en cursos universitarios de teoría de lenguajes y
compiladores, justamente porque combina \textbf{rigor formal} con un
\textbf{diseño práctico}.

\end{document}