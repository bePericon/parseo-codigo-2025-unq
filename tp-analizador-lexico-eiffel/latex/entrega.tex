\documentclass[a4paper,12pt]{article}
\usepackage[utf8]{inputenc}
\usepackage{amsfonts}
\usepackage{enumerate}
\usepackage{amsmath}
\usepackage{array}
\usepackage{xcolor}
\usepackage{graphicx}
\usepackage{listings}
\graphicspath{ {images/} }

\usepackage[top=1in,bottom=1in,left=0.5in,right=0.5in]{geometry}

\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{codered}{rgb}{0.6,0,0}
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}

\lstdefinestyle{myeiffel}{
    backgroundcolor=\color{backcolour},
    commentstyle=\color{codegreen},
    keywordstyle=\color{magenta},
    numberstyle=\tiny\color{codegray},
    stringstyle=\color{codepurple},
    basicstyle=\ttfamily\footnotesize,
    breakatwhitespace=false,
    breaklines=true,
    captionpos=b,
    keepspaces=true,
    % numbers=left,
    numbersep=5pt,
    showspaces=false,
    showstringspaces=false,
    showtabs=false,
    tabsize=2,
    emph={IDENTIFIER, RESERVED_TYPE, STRING, COMMENT, NUMBER},
    emphstyle=\color{magenta},
}

\lstdefinestyle{DOS}{
    backgroundcolor=\color{black},
    basicstyle=\scriptsize\color{white}\ttfamily,
    morekeywords={,tabular,toprule,midrule,bottomrule},
    otherkeywords={:, \$},
    keywordstyle=\color{green},
    emph={username, path},
    emphstyle=\color{green},
}

\title{
    \includegraphics[scale=1.3]{logo-UNQ}\\
    \vspace{4mm}
    \huge{Parseo y generación de código  \\
        \vspace{4mm}
        Trabajo Práctico - Analizador Léxico de Eiffel} }
\author{Jeremias Veliez - B. Emmanuel Pericon}
\date{Septiembre 26, 2025}

\renewcommand{\contentsname}{Indice}

\begin{document}

\maketitle

\tableofcontents

\newpage

\section{Introducción}

\vspace{4mm}
Implementar un analizador léxico para el lenguaje Eiffel, que permita reconocer
correctamente los tokens básicos de un programa escrito en dicho lenguaje.
El analizador se debe construir utilizando las herramientas Flex (generador de
analizadores
léxicos) y Bison (generador de analizadores sintácticos), aunque en esta etapa
del trabajo
sólo se requerirá implementar la parte léxica.

\vspace{6mm}
\section{Diseño y uso del analizador}
\vspace{4mm}

En este analizador tenemos dos archivos importantes, que son:

\begin{itemize}
    \item Por un lado el \textbf{eiffel.l}, que contiene la definición de
          las
          expresiones regulares de los tokens, directamente relacionado con
          \textbf{Flex}.
    \item Y por otro, el archivo \textbf{syntacticAnalyzer.y}, utilizado
          por
          \textbf{Bison} para coordinar la lectura de tokens y dar una
          salida entendible.
\end{itemize}

\noindent
Para esta entrega vamos a centrarnos en el primer archivo ya que el segundo
solo toma directamente los tokens y los devuelve.

\vspace{4mm}
\noindent
Necesitamos realizar una compilación de los archivos de la siguiente manera:

\begin{lstlisting}[style=DOS]
username:path$  flex eiffel.l
username:path$  bison -d syntacticAnalyzer.y
username:path$  gcc -o executable lex.yy.c syntacticAnalyzer.tab.c
\end{lstlisting}

\vspace{4mm}
\noindent
Por ejemplo, para el siguiente codigo en el archivo \textbf{tests/test.e}:

\begin{lstlisting}[language=Eiffel, style=myeiffel]
class HELLO_WORLD
create
    make
feature
    make
        do
            print ("Hola,utilizo Eiffel!%N")
        end
end
\end{lstlisting}

\vspace{4mm}
\noindent
A la hora de ejecutarse se realiza y ve de esta manera:

\begin{lstlisting}[style=DOS]
username:path$  ./executable  < tests/test.e 
TOKEN_CLASS                   -> class
TOKEN_IDENTIFIER              -> HELLO_WORLD
TOKEN_CREATE                  -> create
TOKEN_MAKE                    -> make
TOKEN_FEATURE                 -> feature
TOKEN_MAKE                    -> make
TOKEN_DO                      -> do
TOKEN_PRINT                   -> print
TOKEN_PARENTHESIS_OPEN        -> (
TOKEN_STRING                  -> "Hola,utilizo Eiffel!%N"
TOKEN_PARENTHESIS_CLOSE       -> )
TOKEN_END                     -> end
TOKEN_END                     -> end
\end{lstlisting}

\vspace{6mm}
\section{Expresiones regulares utilizadas}
\vspace{4mm}

Se trato de obtener la mayor cantidad de tokens posibles con las expresiones a
continuación:

\begin{lstlisting}[language=Eiffel, style=myeiffel]
"class"           { return CLASS; }
"inherit"         { return INHERIT; }
"create"          { return CREATE; }
"feature"         { return FEATURE; }
"main"            { return MAIN; }
"do"              { return DO; }
"from"            { return FROM; }
"until"           { return UNTIL; }
"loop"            { return LOOP; }
"end"             { return END; }
"if"              { return IF; }
"then"            { return THEN; }
"else"            { return ELSE; }
"make"            { return MAKE; }
"print"           { return PRINT; }
{RESERVED_TYPE}   { return RESERVED_TYPE; }
"+"               { return PLUS; }
"-"               { return MINUS; }
"*"               { return TIMES; }
"/"               { return DIVIDE; }
">"               { return GREATER; }
"<"               { return LESS; }
"="               { return EQUAL; }
"!="              { return NOT_EQUAL; }
">="              { return GREATER_EQUAL; }
"<="              { return LESS_EQUAL; }
"not"             { return NOT; }
"and"             { return AND; }
"or"              { return OR; }
"true"            { return TRUE; }
"false"           { return FALSE; }
":="              { return ASSIGN; }
":"               { return COLON; }
","               { return COMMA; }
"("               { return PARENTHESIS_OPEN; }
{STR}             { return STRING; }
")"               { return PARENTHESIS_CLOSE; }
{COMMENT}         { return COMMENT; }
{IDENTIFIER}      { return IDENTIFIER; }
{NUMBER}          { return NUMBER; }

[ \t\n\r]+        ;
.                 { return UNKNOWN; }
\end{lstlisting}

\newpage

\noindent
Algunos expresiones particulares fueron:

\begin{lstlisting}[style=myeiffel]
\\ Toda palabra con letras minusculas/mayusculas y/o guion bajo
IDENTIFIER [a-zA-Z][0-9_a-zA-Z]*  

\\ Uno o mas numeros
NUMBER [0-9]+

\\ Todo string, cualquier caracter que se encuentre entre comillas
STR \"[^\"]*\"

\\ Algunas palabras reservadas para tipos
RESERVED_TYPE (INTEGER|BOOLEAN|STRING)

\\ Los comentarios, estos comienzan con doble guion medio
COMMENT \-{2}.*

\\ Ignorar espacios y saltos de linea
[ \t\n\r]+ 

\\ El punto devuelve como UNKNOWN lo que no es reconocido por el resto de expresiones
.
\end{lstlisting}

\vspace{6mm}
\section{Reseña del lenguaje Eiffel y su origen}
\vspace{4mm}

\subsection{Reseña del lenguaje Eiffel}

Eiffel es un lenguaje de programación orientado a objetos, creado a mediados de
los años 80 por \textbf{Bertrand Meyer}, un informático francés, mientras
trabajaba en la empresa \textit{Interactive Software Engineering} (ISE).

\noindent
Su diseño está fuertemente ligado al ámbito académico, ya que Meyer era
profesor e
investigador y buscaba un lenguaje que sirviera como vehículo académico para
difundir y aplicar los principios de \textit{programación por contrato}
(\textit{Design by Contract}), una metodología introducida por Meyer que
establece que cada componente de software debe definirse con
\textbf{precondiciones, postcondiciones e invariantes}. Esto promueve la
confiabilidad, reutilización y mantenibilidad del código.

\noindent
El nombre Eiffel hace referencia a la \textit{torre Eiffel} en París, símbolo
de ingeniería sólida y elegante, lo cual refleja el espíritu con el que fue
concebido: construir sistemas de software tan robustos y bien diseñados como
una obra de ingeniería.

\subsection{Principios fundamentales de Eiffel}

\begin{itemize}
    \item \textbf{Orientación a objetos pura}: todo en Eiffel es objeto,
          incluso los tipos básicos.
    \item \textbf{Diseño por contrato (Design by Contract, DbC)}:
          \begin{itemize}
              \item Una de sus mayores innovaciones.
              \item Cada clase, método o módulo se especifica con
                    precondiciones,
                    postcondiciones e invariantes, como un contrato formal
                    entre el código y sus
                    usuarios.
              \item Esto fomenta la confiabilidad y la verificación del
                    software.
          \end{itemize}
    \item \textbf{Simplicidad y legibilidad}: la sintaxis busca ser clara y
          cercana al lenguaje natural.
    \item \textbf{Soporte de herencia múltiple y polimorfismo}.
\end{itemize}

\subsection{Origen universitario}

Bertrand Meyer desarrolló Eiffel inicialmente en el IT Department de
\textit{Interactive Software Engineering} (hoy Eiffel Software), pero el
lenguaje alcanzó su madurez y estandarización en el ámbito universitario, sobre
todo en el \textbf{ETH Zürich} (Escuela Politécnica Federal de Zúrich, Suiza),
donde Meyer ejerció como profesor de informática desde los años 90.

\noindent
Desde entonces, Eiffel ha sido un lenguaje estrechamente ligado a la academia,
aunque también tuvo aplicaciones en la industria en sectores donde la
confiabilidad del software es crítica (banca, aeroespacial, defensa).

\subsection{Legado}

Aunque no alcanzó la popularidad masiva de Java o C++, Eiffel influyó
enormemente en la evolución del software: el concepto de \textit{Design by
    Contract} fue adoptado por otros lenguajes (Ada 2012, C\#, Java mediante
librerías, Python mediante decoradores, etc.).

\noindent
Sigue siendo un referente en cursos universitarios de teoría de lenguajes y
compiladores, justamente porque combina \textbf{rigor formal} con un
\textbf{diseño práctico}.

\end{document}